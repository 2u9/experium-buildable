//Deobfuscated with https://github.com/SimplyProgrammer/Minecraft-Deobfuscator3000 using mappings "C:\Users\Luni\Documents\1.12 stable mappings"!

// 
// Decompiled by Procyon v0.5.36
// 

package dev._3000IQPlay.experium.features.modules.exploit;

import net.minecraft.init.Items;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;
import net.minecraft.util.EnumHand;
import dev._3000IQPlay.experium.event.events.BlockEvent;
import dev._3000IQPlay.experium.util.RenderUtil;
import net.minecraft.util.math.MathHelper;
import dev._3000IQPlay.experium.Experium;
import net.minecraft.util.math.AxisAlignedBB;
import dev._3000IQPlay.experium.event.events.Render3DEvent;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketHeldItemChange;
import dev._3000IQPlay.experium.util.InventoryUtil;
import net.minecraft.item.ItemPickaxe;
import net.minecraft.world.World;
import net.minecraft.init.Blocks;
import dev._3000IQPlay.experium.util.MathUtil;
import dev._3000IQPlay.experium.util.Timer;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.math.BlockPos;
import java.awt.Color;
import dev._3000IQPlay.experium.features.setting.Setting;
import dev._3000IQPlay.experium.features.modules.Module;

public class PacketmineOLD extends Module
{
    public Setting<Boolean> autoSwitch;
    public Setting<Boolean> render;
    public Setting<Double> resetRange;
    public Setting<Boolean> statusColor;
    public Setting<RenderModes> renderMode;
    public Setting<StatusModes> statusModes;
    public Setting<Integer> red;
    public Setting<Integer> green;
    public Setting<Integer> blue;
    public Setting<Integer> alpha;
    public Color fagColor;
    public BlockPos renderPos;
    public BlockPos breakPos;
    public EnumFacing breakFace;
    public Timer timer;
    public boolean readyToMine;
    public int oldSlot;
    
    public PacketmineOLD() {
        super("PacketmineOLD", "Breaks block with packets.", Category.EXPLOIT, true, false, false);
        this.autoSwitch = (Setting<Boolean>)this.register(new Setting("SilentSwitch", (T)false));
        this.render = (Setting<Boolean>)this.register(new Setting("Render", (T)true));
        this.resetRange = (Setting<Double>)this.register(new Setting("ResetRange", (T)10.0, (T)0.0, (T)50.0));
        this.statusColor = (Setting<Boolean>)this.register(new Setting("StatusColor", (T)false));
        this.renderMode = (Setting<RenderModes>)this.register(new Setting("RenderMode", (T)RenderModes.STATIC));
        this.statusModes = (Setting<StatusModes>)this.register(new Setting("StatusMode", (T)StatusModes.STATIC));
        this.red = (Setting<Integer>)this.register(new Setting("Red", (T)0, (T)0, (T)255));
        this.green = (Setting<Integer>)this.register(new Setting("Green", (T)255, (T)0, (T)255));
        this.blue = (Setting<Integer>)this.register(new Setting("Blue", (T)0, (T)0, (T)255));
        this.alpha = (Setting<Integer>)this.register(new Setting("Alpha", (T)125, (T)0, (T)255));
        this.renderPos = null;
        this.breakPos = null;
        this.breakFace = null;
        this.timer = new Timer();
        this.readyToMine = false;
        this.oldSlot = -1;
    }
    
    @Override
    public void onUpdate() {
        this.fagColor = new Color(this.red.getValue(), this.green.getValue(), this.blue.getValue());
        if (PacketmineOLD.mc.player != null && PacketmineOLD.mc.world != null && this.breakPos != null) {
            this.oldSlot = PacketmineOLD.mc.player.inventory.currentItem;
            if (PacketmineOLD.mc.player.getDistanceSq(this.breakPos) > MathUtil.square(this.resetRange.getValue()) || PacketmineOLD.mc.world.getBlockState(this.breakPos).getBlock() == Blocks.AIR) {
                this.breakPos = null;
                this.breakFace = null;
                this.readyToMine = false;
                return;
            }
            if (this.render.getValue()) {
                this.renderPos = this.breakPos;
            }
            final float breakTime;
            if (this.timer.hasReached((long)(breakTime = PacketmineOLD.mc.world.getBlockState(this.breakPos).getBlockHardness((World)PacketmineOLD.mc.world, this.breakPos)))) {
                this.readyToMine = true;
            }
            if (this.autoSwitch.getValue()) {
                if (this.timer.hasReached((long)breakTime) && InventoryUtil.findHotbarBlock(ItemPickaxe.class) != -1) {
                    PacketmineOLD.mc.player.connection.sendPacket((Packet)new CPacketHeldItemChange(this.pickaxeInHotbar()));
                }
                PacketmineOLD.mc.getConnection().sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, this.breakPos, this.breakFace));
                if (this.oldSlot != -1) {
                    PacketmineOLD.mc.player.connection.sendPacket((Packet)new CPacketHeldItemChange(this.oldSlot));
                }
            }
        }
    }
    
    @Override
    public void onRender3D(final Render3DEvent event) {
        if (PacketmineOLD.mc.player == null || PacketmineOLD.mc.world == null) {
            return;
        }
        if (this.render.getValue() && this.breakPos != null && PacketmineOLD.mc.world.getBlockState(this.breakPos).getBlock() != Blocks.AIR) {
            final Color defColor = new Color(this.fagColor.getRed(), this.fagColor.getGreen(), this.fagColor.getBlue(), this.alpha.getValue());
            final AxisAlignedBB bb = new AxisAlignedBB(this.breakPos.getX() - PacketmineOLD.mc.getRenderManager().viewerPosX, this.breakPos.getY() - PacketmineOLD.mc.getRenderManager().viewerPosY, this.breakPos.getZ() - PacketmineOLD.mc.getRenderManager().viewerPosZ, this.breakPos.getX() + 1 - PacketmineOLD.mc.getRenderManager().viewerPosX, this.breakPos.getY() + 1 - PacketmineOLD.mc.getRenderManager().viewerPosY, this.breakPos.getZ() + 1 - PacketmineOLD.mc.getRenderManager().viewerPosZ);
            final float breakTime = PacketmineOLD.mc.world.getBlockState(this.breakPos).getBlockHardness((World)PacketmineOLD.mc.world, this.breakPos);
            final double progression = this.timer.getPassedTimeMs() / 40.0f / breakTime * Experium.serverManager.getTpsFactor();
            final double oldMaxY = bb.maxY;
            final double upY = progression * (bb.maxY - bb.minY);
            final AxisAlignedBB riseBB = new AxisAlignedBB(bb.minX, bb.minY, bb.minZ, bb.maxX, bb.minY + upY, bb.maxZ);
            final float sGreen = MathHelper.clamp((float)upY, 0.0f, 1.0f);
            final Color color = this.statusModes.getValue().equals(StatusModes.STATIC) ? new Color(this.timer.hasReached((long)breakTime) ? 0 : 255, this.timer.hasReached((long)breakTime) ? 255 : 0, 0, this.alpha.getValue()) : new Color(255 - (int)(sGreen * 150.0f), (int)(sGreen * 255.0f), 0, this.alpha.getValue());
            final float fadeA = MathHelper.clamp((float)upY, 0.0f, 1.0f);
            final Color alphaFade = new Color(defColor.getRed(), defColor.getGreen(), defColor.getBlue(), (int)(fadeA * 255.0f));
            if (this.renderMode.getValue().equals(RenderModes.RISE)) {
                if (riseBB.maxY <= oldMaxY) {
                    RenderUtil.drawFilledBox(riseBB, ((boolean)this.statusColor.getValue()) ? color.getRGB() : defColor.getRGB());
                    RenderUtil.drawBlockOutline(riseBB, ((boolean)this.statusColor.getValue()) ? color : defColor, 1.0f);
                }
                if (riseBB.maxY >= oldMaxY) {
                    RenderUtil.drawFilledBox(bb, ((boolean)this.statusColor.getValue()) ? color.getRGB() : defColor.getRGB());
                    RenderUtil.drawBlockOutline(bb, ((boolean)this.statusColor.getValue()) ? color : defColor, 1.0f);
                }
            }
            else if (this.renderMode.getValue().equals(RenderModes.STATIC)) {
                RenderUtil.drawFilledBox(bb, ((boolean)this.statusColor.getValue()) ? color.getRGB() : defColor.getRGB());
                RenderUtil.drawBlockOutline(bb, ((boolean)this.statusColor.getValue()) ? color : defColor, 1.0f);
            }
            else if (this.renderMode.getValue().equals(RenderModes.FADE)) {
                RenderUtil.drawFilledBox(bb, ((boolean)this.statusColor.getValue()) ? new Color(color.getRed(), color.getGreen(), color.getBlue(), (int)(fadeA * 255.0f)).getRGB() : alphaFade.getRGB());
                RenderUtil.drawBlockOutline(bb, ((boolean)this.statusColor.getValue()) ? new Color(color.getRed(), color.getGreen(), color.getBlue(), (int)(fadeA * 255.0f)) : alphaFade, 1.0f);
            }
        }
    }
    
    @SubscribeEvent
    public void onBlockEvent(final BlockEvent event) {
        if (PacketmineOLD.mc.player == null || PacketmineOLD.mc.world == null) {
            return;
        }
        if (canBlockBeBroken(event.pos)) {
            if (this.breakPos == null) {
                this.breakPos = event.pos;
                this.breakFace = event.facing;
                this.readyToMine = false;
                this.timer.reset();
            }
            PacketmineOLD.mc.player.swingArm(EnumHand.MAIN_HAND);
            PacketmineOLD.mc.player.connection.sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK, this.breakPos, this.breakFace));
            PacketmineOLD.mc.player.connection.sendPacket((Packet)new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK, this.breakPos, this.breakFace));
            event.setCanceled(true);
        }
    }
    
    public static boolean canBlockBeBroken(final BlockPos pos) {
        final IBlockState blockState = PacketmineOLD.mc.world.getBlockState(pos);
        final Block block = blockState.getBlock();
        return block.getBlockHardness(blockState, (World)PacketmineOLD.mc.world, pos) != -1.0f;
    }
    
    public int pickaxeInHotbar() {
        for (int i = 0; i < 9; ++i) {
            if (PacketmineOLD.mc.player.inventory.getStackInSlot(i).getItem() == Items.DIAMOND_PICKAXE) {
                return i;
            }
        }
        return -1;
    }
    
    @Override
    public void onEnable() {
        this.breakPos = null;
    }
    
    @Override
    public void onDisable() {
        this.breakPos = null;
    }
    
    @Override
    public String getDisplayInfo() {
        String t = "";
        if (this.breakPos == null) {
            return null;
        }
        if (this.breakPos != null && !this.timer.passedMs((int)(2000.0f * Experium.serverManager.getTpsFactor()))) {
            t = "§cMining";
        }
        else if (this.breakPos != null && this.timer.passedMs((int)(2000.0f * Experium.serverManager.getTpsFactor()))) {
            t = "§aReady";
        }
        return t;
    }
    
    public enum StatusModes
    {
        STATIC, 
        SMOOTH;
    }
    
    public enum RenderModes
    {
        RISE, 
        FADE, 
        STATIC;
    }
}
